import java.util.Arrays;

public class Main {
    public static void main(String[] args) {

        int[] a = { 5, 8, 2, 3, 4, 6, 9, 1, 7 };    // Основной массив
        mergeSort(a, a.length);
        System.out.println(Arrays.toString(a));
    }

    public static void mergeSort(int[] a, int n) {      // *Метод плодит и размножает массивы
        if (n < 2) {        // Проверяем размер массива на наличие 1 значения (не больше 2-ух)
            return;
        }
        int mid = n / 2;            // Получаем половину размера массива
        int[] l = new int[mid];         // Создаём Левый массив [половина]
        int[] r = new int[n - mid];     // Создаём Правый массив [размер оригинала - половина]

        for (int i = 0; i < mid; i++) {     // Записываем в Левый[] массив
            l[i] = a[i];
        }
        for (int i = mid; i < n; i++) {     // Записываем в Правый[] массив
            r[i - mid] = a[i];
        }
        mergeSort(l, mid);             // Делим Левый[] массив (Снова)
        mergeSort(r, n - mid);      // Делим Правый[] массив (Снова)

        merge(a, l, r, mid, n - mid);  // Передаём массивы с размерами
    }

    public static void merge(int[] a, int[] l, int[] r, int left, int right) {  // Метод сортирует и собирает по частям

        // Счётчики индексов для массивов. По мере прохождения операций счётчик накапливает значения, перебирая массивы
        int i = 0,      // Левый[]
            j = 0,      // Правый[]
            k = 0;      // Основной[]

        while (i < left && j < right) {     // Проверяем Если индекс меньше размера Левого и Правого массива
            if (l[i] <= r[j]) {         // Сравниваем значения: если Левое[i] меньше Правого[j]
                a[k++] = l[i++];        // Перезаписываем Левый[] в основной[] массив
            }
            else {                      // Иначе: Правое[] меньше Левого[]
                a[k++] = r[j++];        // Перезаписываем Правый[] в основной[] массив
            }
        }
                                // Проверяем на остаточные значения
        while (i < left) {              // Если значение размера i для Левого[] меньше,
            a[k++] = l[i++];            // значит до записываем в основной[] оставшееся из Левого[]
        }
        while (j < right) {             // Если значение размера i для Правого[] меньше,
            a[k++] = r[j++];            // значит до записываем в основной[] оставшееся из Правого[]
        }
    }
}
